<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LatRen — LaTeX → Image (PNG/SVG)</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
  <!-- JSZip for Batch → ZIP (client-side only) -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <style>
    :root{
      --bg: #0b0d12;
      --panel: #121623;
      --panel-2: #0e1320;
      --text: #e6ecff;
      --muted: #a1accf;
      --accent: #7aa2ff;
      --accent-2: #00d4ff;
      --success: #6be675;
      --danger: #ff7a84;
      --warning: #ffb454;
      --border: #232a46;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --popover: #0c1020;
    }
    .light{
      --bg: #f7f8fb;
      --panel: #ffffff;
      --panel-2: #f3f6ff;
      --text: #111525;
      --muted: #4b5578;
      --accent: #305eff;
      --accent-2: #00a3c4;
      --success: #229954;
      --danger: #cb2b3e;
      --warning: #d18609;
      --border: #dfe6fb;
      --shadow: 0 10px 30px rgba(24, 35, 75, .12);
      --popover: #fff;
    }
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--text);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      line-height:1.45; letter-spacing:.2px;
    }
    .container{max-width:1200px; margin:0 auto; padding:24px;}
    header{background:linear-gradient(135deg, var(--panel-2), transparent 60%), linear-gradient(45deg, rgba(48,94,255,.15), rgba(0,212,255,.05)); border-bottom:1px solid var(--border); position:sticky; top:0; z-index:10; backdrop-filter: blur(8px);}
    .hdr-inner{display:flex; align-items:center; justify-content:space-between; gap:16px;}
    .brand{display:flex; align-items:center; gap:12px;}
    .logo{width:40px; height:40px; border-radius:12px; background:radial-gradient(120px 50px at 30% 30%, var(--accent), transparent 70%), radial-gradient(120px 50px at 70% 70%, var(--accent-2), transparent 70%), linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,0)); box-shadow:var(--shadow);}
    .title{font-weight:800; font-size:20px; letter-spacing:0.5px}
    .badge{font-size:12px; padding:6px 10px; border:1px solid var(--border); border-radius:999px; color:var(--muted);}
    .toolbar{display:flex; gap:10px; align-items:center}
    .switch{display:inline-flex; align-items:center; gap:8px; font-size:13px; color:var(--muted)}
    .switch input{appearance:none; width:44px; height:26px; background:var(--panel); border:1px solid var(--border); border-radius:999px; position:relative; outline:none; cursor:pointer; transition:.2s}
    .switch input:checked{background:linear-gradient(45deg, var(--accent), var(--accent-2))}
    .switch input::after{content:""; position:absolute; top:3px; left:3px; width:20px; height:20px; background:#fff; border-radius:50%; transition:.2s}
    .switch input:checked::after{left:21px}

    main{padding-top:18px}
    .grid{display:grid; grid-template-columns: 1.1fr .9fr; gap:18px}

    .panel{background:var(--panel); border:1px solid var(--border); border-radius:16px; box-shadow:var(--shadow)}
    .panel h2{margin:0; padding:14px 16px; font-size:14px; letter-spacing:.5px; text-transform:uppercase; color:var(--muted); border-bottom:1px solid var(--border)}
    .panel .body{padding:16px}

    textarea{
      width:100%; min-height:260px; resize:vertical; border-radius:12px; border:1px solid var(--border);
      background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,0)); color:var(--text);
      font: 14px/1.5 "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      padding:14px; outline:none; box-shadow: inset 0 0 0 999px rgba(0,0,0,0);
    }
    textarea:focus{border-color:var(--accent); box-shadow:0 0 0 3px rgba(122,162,255,.25)}

    .controls{display:flex; flex-wrap:wrap; gap:10px; margin-top:12px}
    .controls .group{display:flex; align-items:center; gap:8px; background:var(--panel-2); border:1px solid var(--border); border-radius:12px; padding:8px 10px}
    .controls .group label{font-size:12px; color:var(--muted)}
    input[type="number"], input[type="text"], select{background:transparent; border:1px solid var(--border); border-radius:10px; color:var(--text); padding:6px 8px; outline:none}
    input[type="color"]{appearance:none; border:none; background:transparent; width:28px; height:28px}
    .btn{
      appearance:none; border:none; background:linear-gradient(45deg, var(--accent), var(--accent-2)); color:white; padding:10px 14px; border-radius:12px; font-weight:600; cursor:pointer; box-shadow:var(--shadow);
      transition:transform .08s ease;
    }
    .btn:hover{transform:translateY(-1px)}
    .btn.secondary{background:transparent; color:var(--text); border:1px solid var(--border)}
    .btn.warn{background:linear-gradient(45deg, var(--warning), #ffda8a)}
    .btn.good{background:linear-gradient(45deg, var(--success), #9ef7a7)}
    .btn.bad{background:linear-gradient(45deg, var(--danger), #ffb1b7)}

    .row{display:flex; gap:10px; flex-wrap:wrap}
    .row > *{flex:1}

    .templates-toolbar{display:flex; align-items:center; justify-content:space-between; gap:12px; margin-top:12px; position:relative;}
    .templates{display:flex; gap:6px; flex-wrap:wrap; margin-top:8px}
    .template{font-size:12px; padding:6px 8px; border-radius:10px; border:1px solid var(--border); background:var(--panel-2); cursor:pointer}

    .dropdown{position:absolute; right:0; top:100%; margin-top:8px; width:290px; background:var(--popover); border:1px solid var(--border); border-radius:12px; box-shadow:var(--shadow); padding:10px; z-index:20;}
    .dropdown h3{margin:0 0 8px 0; font-size:13px; color:var(--muted); text-transform:uppercase; letter-spacing:.4px}
    .dropdown .row{display:flex; gap:6px; margin:8px 0 6px 0}
    .dropdown .pill{font-size:12px; padding:4px 8px; border-radius:999px; border:1px solid var(--border); background:var(--panel-2); cursor:pointer}
    .dropdown .catlist{display:grid; grid-template-columns: 1fr 1fr; gap:8px; max-height:260px; overflow:auto; padding-right:2px}
    .dropdown label{display:flex; align-items:center; gap:8px; font-size:13px}
    .dropdown small{color:var(--muted); display:block; margin-top:6px}

    .preview-wrap{padding:16px}
    .canvas-wrap{display:flex; align-items:center; justify-content:center; min-height:260px; background: repeating-conic-gradient(#0000 0 25%, rgba(127,127,127,.1) 0 50%) 50% / 16px 16px; border:1px dashed var(--border); border-radius:12px}
    .preview{max-width:100%; height:auto; display:block}
    .meta{display:flex; gap:12px; flex-wrap:wrap; color:var(--muted); font-size:13px; margin-top:8px}

    details.instructions{margin-top:14px; background:var(--panel-2); border:1px solid var(--border); border-radius:12px; padding:12px 14px}
    details.instructions summary{cursor:pointer; font-weight:600}
    details.instructions p{color:var(--muted); margin:.4em 0}

    .status{margin-top:10px; font-size:13px; white-space:pre-wrap}
    .status.ok{color:var(--success)}
    .status.err{color:var(--danger)}

    .history{display:grid; grid-template-columns: repeat(auto-fill, minmax(210px, 1fr)); gap:12px}
    .card{background:var(--panel); border:1px solid var(--border); border-radius:12px; overflow:hidden; display:flex; flex-direction:column}
    .card img{width:100%; height:160px; object-fit:contain; background: #0a0a0a10}
    .card .info{padding:10px}
    .card .info small{color:var(--muted)}
    .card .actions{display:flex; gap:8px; padding:10px}

    footer{margin-top:32px; padding:18px 0; color:var(--muted); border-top:1px solid var(--border)}
    code.inline{font-family:"JetBrains Mono", monospace; background:rgba(122,162,255,.12); padding:.2em .45em; border-radius:6px}


/* --- Solve panel styles (uses existing design tokens) --- */
.solve-panel{
  margin-top:12px;
  background:var(--panel);
  border:1px solid var(--border);
  border-radius:12px;
  padding:12px 14px;
}
.solve-panel h3{
  margin:0 0 6px 0; font-size:14px; letter-spacing:.4px; text-transform:uppercase; color:var(--muted);
}
.solve-meta{ color:var(--muted); font-size:13px; margin-bottom:8px }
.solve-steps{ counter-reset: step; list-style:decimal; padding-left:20px; }
.solve-steps li{ margin:8px 0; }
.solve-what{ font-weight:600 }
.solve-why{ color:var(--muted); font-size:12px }
.solve-math{ margin-top:4px }
.code-list{ margin-top:10px; background:var(--panel-2); border:1px solid var(--border); border-radius:10px; padding:8px }
.code-row{ display:flex; align-items:center; gap:8px; margin:6px 0 }
.code-row code{ white-space:nowrap; overflow:auto; display:block; padding:.25rem .5rem; border:1px solid var(--border); border-radius:8px; background:var(--panel); font-family:"JetBrains Mono", monospace; font-size:12px }
.mini{ padding:6px 8px; border-radius:10px; font-size:12px }
.answers{ margin-top:10px; padding:8px; background:var(--panel-2); border:1px solid var(--border); border-radius:10px }
.badge-ok{ display:inline-block; padding:2px 6px; border-radius:999px; border:1px solid var(--border); margin-left:6px; }
.verify{ margin-top:8px; font-size:13px; color:var(--muted) }
.solve-err{ background: linear-gradient(0deg, rgba(255,122,132,.08), rgba(255,122,132,.08)), var(--panel); border:1px solid var(--danger); color:var(--text); padding:10px 12px; border-radius:12px }

    @media (max-width: 980px){
      .grid{grid-template-columns: 1fr}
      .dropdown{right:auto; left:0;}
    }
  </style>

  <!-- MathJax (TeX → SVG). -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'],['\\(','\\)']],
        displayMath: [['$$','$$'],['\\[','\\]']],
        packages: {'[+]': ['base','ams']},  // ams for aligned/flalign/etc.
        maxBuffer: 10000
      },
      svg: { fontCache: 'none' },
      options: { enableMenu: false }
    };
  </script>
  <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-svg.js"></script>
</head>
<body class="light" id="body">
  <header>
    <div class="container hdr-inner">
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div>
          <div class="title">LatRen</div>
          <div class="badge">Standalone LaTeX → Image Toolkit</div>
        </div>
      </div>
      <div class="toolbar">
        <label class="switch" title="Toggle theme">
          <input id="themeToggle" type="checkbox" />
          <span>Dark mode</span>
        </label>
      </div>
    </div>
  </header>

  <main class="container">
    <div class="grid">
      <section class="panel" aria-labelledby="editor-title">
        <h2 id="editor-title">Editor</h2>
        <div class="body">
          <div class="row">
            <div>
              <label for="latex" class="badge">LaTeX Input</label>
              <textarea id="latex" spellcheck="false" placeholder="Type LaTeX here...">\[
\text{Welcome to LatRen! Render: Ctrl/⌘+Enter · PNG: Ctrl/⌘+S · Copy: Ctrl/⌘+K}
\]
\[\text{Separate formulas with a blank line for Batch → ZIP. Use single backslashes.}\]
</textarea>
            </div>
          </div>

          <div class="templates-toolbar">
            <div class="badge">Math Keys</div>
            <div style="display:flex; gap:8px; align-items:center;">
              <button class="btn secondary" id="templateFilterBtn" aria-haspopup="true" aria-expanded="false" type="button">Categories ▾</button>
              <span id="catSummary" style="font-size:12px; color:var(--muted)"></span>
            </div>
            <div class="dropdown" id="templateDropdown" hidden>
              <h3>Show categories</h3>
              <div class="row">
                <button class="pill" id="selectAll" type="button">All</button>
                <button class="pill" id="selectNone" type="button">None</button>
                <button class="pill" id="selectIB" type="button">IB Core</button>
              </div>
              <div class="catlist" id="catList"></div>
              <small>Selections persist locally.</small>
            </div>
          </div>

          <div class="templates" id="templates">
            <!-- Basics -->
            <button class="template" data-cat="basics" data-snippet="x^2">x²</button>
            <button class="template" data-cat="basics" data-snippet="x^{n}">xⁿ</button>
            <button class="template" data-cat="basics" data-snippet="x_{i}">xᵢ</button>
            <button class="template" data-cat="basics" data-snippet="\frac{a}{b}">a⁄b</button>
            <button class="template" data-cat="basics" data-snippet="\sqrt{x}">√x</button>
            <button class="template" data-cat="basics" data-snippet="\sqrt[n]{x}">ⁿ√x</button>
            <button class="template" data-cat="basics" data-snippet="\lvert x \rvert">|x|</button>
            <button class="template" data-cat="basics" data-snippet="\lVert \mathbf{x} \rVert">‖x‖</button>
            <button class="template" data-cat="basics" data-snippet="\lfloor x \rfloor">⌊x⌋</button>
            <button class="template" data-cat="basics" data-snippet="\lceil x \rceil">⌈x⌉</button>
            <button class="template" data-cat="basics" data-snippet="\overline{AB}">AB̅</button>
            <button class="template" data-cat="basics" data-snippet="\vec{v}">v⃗</button>
            <button class="template" data-cat="basics" data-snippet="\hat{y}">ŷ</button>
            <button class="template" data-cat="basics" data-snippet="\bar{x}">x̄</button>
            <button class="template" data-cat="basics" data-snippet="\dot{x}">ẋ</button>
            <button class="template" data-cat="basics" data-snippet="\ddot{x}">ẍ</button>
            <button class="template" data-cat="basics" data-snippet="f(x)=">f(x)=</button>
            <button class="template" data-cat="basics" data-snippet="( \, )">( )</button>
            <button class="template" data-cat="basics" data-snippet="[ \]">[ ]</button>
            <button class="template" data-cat="basics" data-snippet="\{ \, \}">{ }</button>

            <!-- Constants & sets -->
            <button class="template" data-cat="constants" data-snippet="\pi">π</button>
            <button class="template" data-cat="constants" data-snippet="e^{x}">eˣ</button>
            <button class="template" data-cat="constants" data-snippet="\infty">∞</button>
            <button class="template" data-cat="constants" data-snippet="\mathbb{R}">ℝ</button>
            <button class="template" data-cat="constants" data-snippet="\mathbb{Z}">ℤ</button>
            <button class="template" data-cat="constants" data-snippet="\mathbb{N}">ℕ</button>
            <button class="template" data-cat="constants" data-snippet="\mathbb{Q}">ℚ</button>
            <button class="template" data-cat="constants" data-snippet="\mathbb{C}">ℂ</button>

            <!-- Greek -->
            <button class="template" data-cat="greek" data-snippet="\alpha">α</button>
            <button class="template" data-cat="greek" data-snippet="\beta">β</button>
            <button class="template" data-cat="greek" data-snippet="\gamma">γ</button>
            <button class="template" data-cat="greek" data-snippet="\Delta">Δ</button>
            <button class="template" data-cat="greek" data-snippet="\theta">θ</button>
            <button class="template" data-cat="greek" data-snippet="\lambda">λ</button>
            <button class="template" data-cat="greek" data-snippet="\mu">μ</button>
            <button class="template" data-cat="greek" data-snippet="\sigma">σ</button>
            <button class="template" data-cat="greek" data-snippet="\Sigma">Σ</button>
            <button class="template" data-cat="greek" data-snippet="\phi">φ</button>
            <button class="template" data-cat="greek" data-snippet="\omega">ω</button>
            <button class="template" data-cat="greek" data-snippet="\Omega">Ω</button>
            <button class="template" data-cat="greek" data-snippet="\partial">∂</button>

            <!-- Trig / exp / logs -->
            <button class="template" data-cat="trig" data-snippet="\sin(x)">sin</button>
            <button class="template" data-cat="trig" data-snippet="\cos(x)">cos</button>
            <button class="template" data-cat="trig" data-snippet="\tan(x)">tan</button>
            <button class="template" data-cat="trig" data-snippet="\csc(x)">csc</button>
            <button class="template" data-cat="trig" data-snippet="\sec(x)">sec</button>
            <button class="template" data-cat="trig" data-snippet="\cot(x)">cot</button>
            <button class="template" data-cat="trig" data-snippet="\arcsin(x)">sin⁻¹</button>
            <button class="template" data-cat="trig" data-snippet="\arccos(x)">cos⁻¹</button>
            <button class="template" data-cat="trig" data-snippet="\arctan(x)">tan⁻¹</button>
            <button class="template" data-cat="trig" data-snippet="\sinh(x)">sinh</button>
            <button class="template" data-cat="trig" data-snippet="\cosh(x)">cosh</button>
            <button class="template" data-cat="trig" data-snippet="\tanh(x)">tanh</button>
            <button class="template" data-cat="trig" data-snippet="\ln(x)">ln</button>
            <button class="template" data-cat="trig" data-snippet="\log(x)">log</button>
            <button class="template" data-cat="trig" data-snippet="\log_{b}(x)">log₍ᵦ₎</button>

            <!-- Calculus -->
            <button class="template" data-cat="calculus" data-snippet="\frac{d}{dx} f(x)">d/dx</button>
            <button class="template" data-cat="calculus" data-snippet="\frac{d^{n}}{dx^{n}} f(x)">dⁿ/dxⁿ</button>
            <button class="template" data-cat="calculus" data-snippet="\frac{\partial f}{\partial x}">∂/∂x</button>
            <button class="template" data-cat="calculus" data-snippet="\nabla f">∇f</button>
            <button class="template" data-cat="calculus" data-snippet="\int f(x)\,dx">∫</button>
            <button class="template" data-cat="calculus" data-snippet="\int_{a}^{b} f(x)\,dx">∫ₐᵇ</button>
            <button class="template" data-cat="calculus" data-snippet="\iint_{D} f(x,y)\,dA">∬</button>
            <button class="template" data-cat="calculus" data-snippet="\iiint_{V} f(x,y,z)\,dV">∭</button>
            <button class="template" data-cat="calculus" data-snippet="\lim_{x\to a} f(x)">lim</button>
            <button class="template" data-cat="calculus" data-snippet="\sum_{k=1}^{n} a_k">∑</button>
            <button class="template" data-cat="calculus" data-snippet="\prod_{k=1}^{n} a_k">∏</button>
            <button class="template" data-cat="calculus" data-snippet="\int_{-\infty}^{\infty} e^{-x^2}\,dx=\sqrt{\pi}">∫e^{-x²}</button>

            <!-- Algebra / relations -->
            <button class="template" data-cat="algebra" data-snippet="\cdot">·</button>
            <button class="template" data-cat="algebra" data-snippet="\times">×</button>
            <button class="template" data-cat="algebra" data-snippet="\div">÷</button>
            <button class="template" data-cat="algebra" data-snippet="\pm">±</button>
            <button class="template" data-cat="algebra" data-snippet="\mp">∓</button>
            <button class="template" data-cat="algebra" data-snippet="\le">≤</button>
            <button class="template" data-cat="algebra" data-snippet="\ge">≥</button>
            <button class="template" data-cat="algebra" data-snippet="\neq">≠</button>
            <button class="template" data-cat="algebra" data-snippet="\approx">≈</button>
            <button class="template" data-cat="algebra" data-snippet="\equiv">≡</button>
            <button class="template" data-cat="algebra" data-snippet="\propto">∝</button>
            <button class="template" data-cat="algebra" data-snippet="\sim">∼</button>
            <button class="template" data-cat="algebra" data-snippet="\in">∈</button>
            <button class="template" data-cat="algebra" data-snippet="\notin">∉</button>
            <button class="template" data-cat="algebra" data-snippet="\subseteq">⊆</button>
            <button class="template" data-cat="algebra" data-snippet="\supseteq">⊇</button>
            <button class="template" data-cat="algebra" data-snippet="\cup">∪</button>
            <button class="template" data-cat="algebra" data-snippet="\cap">∩</button>
            <button class="template" data-cat="algebra" data-snippet="\setminus">∖</button>
            <button class="template" data-cat="algebra" data-snippet="\{\;x\in\mathbb{R}\mid\;\}">{x|}</button>
            <button class="template" data-cat="algebra" data-snippet="\binom{n}{k}">nCk</button>
            <button class="template" data-cat="algebra" data-snippet="\therefore">∴</button>

            <!-- Arrows -->
            <button class="template" data-cat="arrows" data-snippet="\to">→</button>
            <button class="template" data-cat="arrows" data-snippet="\Rightarrow">⇒</button>
            <button class="template" data-cat="arrows" data-snippet="\leftrightarrow">↔</button>
            <button class="template" data-cat="arrows" data-snippet="\mapsto">↦</button>

            <!-- Matrices / vectors / cases -->
            <button class="template" data-cat="matrices" data-snippet="\begin{bmatrix} a & b \\ c & d \end{bmatrix}">2×2</button>
            <button class="template" data-cat="matrices" data-snippet="\begin{pmatrix} a \\ b \\ c \end{pmatrix}">col</button>
            <button class="template" data-cat="matrices" data-snippet="\det\!\begin{bmatrix} a & b \\ c & d \end{bmatrix}">|A|</button>
            <button class="template" data-cat="matrices" data-snippet="A^{\mathsf{T}}">ᵀ</button>
            <button class="template" data-cat="matrices" data-snippet="\begin{cases} ax+b,& x\ge 0 \\ -x,& x<0 \end{cases}">⎧⎫</button>

            <!-- Geometry -->
            <button class="template" data-cat="geometry" data-snippet="\angle ABC">∠</button>
            <button class="template" data-cat="geometry" data-snippet="^\circ">°</button>
            <button class="template" data-cat="geometry" data-snippet="\triangle ABC">△</button>
            <button class="template" data-cat="geometry" data-snippet="\overrightarrow{AB}">AB⃗</button>

            <!-- Probability / stats -->
            <button class="template" data-cat="probability" data-snippet="\mathbb{E}[X]">𝔼[·]</button>
            <button class="template" data-cat="probability" data-snippet="\mathrm{Var}(X)">Var</button>
            <button class="template" data-cat="probability" data-snippet="P(A\mid B)">P(|)</button>
            <button class="template" data-cat="probability" data-snippet="P(A\cap B)">P(∩)</button>
            <button class="template" data-cat="probability" data-snippet="P(A\cup B)">P(∪)</button>

            <!-- Complex -->
            <button class="template" data-cat="complex" data-snippet="\Re(z)">Re</button>
            <button class="template" data-cat="complex" data-snippet="\Im(z)">Im</button>
            <button class="template" data-cat="complex" data-snippet="\lvert z \rvert">|z|</button>
            <button class="template" data-cat="complex" data-snippet="\arg(z)">arg</button>

            <!-- Series / sequences -->
            <button class="template" data-cat="series" data-snippet="\sum_{k=0}^{n} r^{k}=\frac{1-r^{n+1}}{1-r},\; r\ne1">Geom Σ</button>
            <button class="template" data-cat="series" data-snippet="a_{n}\to L">aₙ→L</button>
            <button class="template" data-cat="series" data-snippet="\frac{n}{2}\left(2a_{1}+(n-1)d\right)=\sum_{k=1}^{n}\left(a_{1}+(k-1)d\right)">Arith Σ</button>

            <!-- Dots / spacing -->
            <button class="template" data-cat="dots" data-snippet="\cdots">⋯</button>
            <button class="template" data-cat="dots" data-snippet="\ldots">…</button>
          </div>

          <div class="controls" aria-label="Render and export controls">
            <button class="btn" id="renderBtn" type="button">Render (Ctrl/⌘+Enter)</button>
            <button class="btn" id="solveBtn" type="button">Solve</button>
            <button class="btn secondary" id="liveToggle" aria-pressed="false" type="button">Live: Off</button>
            <button class="btn good" id="downloadPNGBtn" type="button">Download PNG (Ctrl/⌘+S)</button>
            <button class="btn secondary" id="downloadSVGBtn" type="button">Download SVG</button>
            <button class="btn secondary" id="copyPNGBtn" type="button">Copy PNG</button>
            <button class="btn secondary" id="copySVGBtn" type="button">Copy SVG</button>
            <button class="btn secondary" id="shareBtn" type="button">Share link</button>
            <button class="btn warn" id="saveHistoryBtn" type="button">Save to History</button>
            <button class="btn bad" id="clearBtn" type="button">Clear</button>
            <button class="btn warn" id="batchZipBtn" type="button" title="Split by blank lines → render each → ZIP PNG+SVG">Batch → ZIP</button>
          </div>

          <div class="controls" aria-label="Output options">
            <div class="group"><label for="scale">Scale</label><input id="scale" type="number" min="0.25" step="0.25" value="2" />×</div>
            <div class="group"><label for="padding">Padding</label><input id="padding" type="number" min="0" step="2" value="20" /> px</div>
            <div class="group"><label for="bg">Background</label><input id="bg" type="color" value="#ffffff" title="Background color"/><label><input id="transparent" type="checkbox" /> transparent</label></div>
            </div>

          <div class="status" id="status"></div>

          <details class="instructions">
            <summary>How to use</summary>
            <p>Type math LaTeX (e.g., environments like <code class="inline">aligned</code>, <code class="inline">cases</code>, <code class="inline">bmatrix</code>). Use <code class="inline">$$...$$</code> or block environments — full documents with <code class="inline">\documentclass</code> are <em>not</em> supported.</p>
            <p>Click <strong>Render</strong>, then <strong>Download PNG/SVG</strong>. Adjust <em>scale</em> for resolution and <em>padding</em> for margins. Toggle <em>transparent</em> background for overlays. Use <strong>Share link</strong> to encode your formula in the URL.</p>
            <p>Shortcuts: <code class="inline">Ctrl/⌘+Enter</code> render · <code class="inline">Ctrl/⌘+S</code> download PNG · <code class="inline">Ctrl/⌘+K</code> copy PNG</p>
            <p><strong>Batch → ZIP:</strong> Separate formulas with a blank line. Each block renders to both SVG and PNG inside a ZIP (plus manifest and any errors).</p>
          </details>
        </div>
      </section>

      <section class="panel" aria-labelledby="preview-title">
        <h2 id="preview-title">Preview</h2>
        <div class="preview-wrap">
          <div class="canvas-wrap">
            <img id="preview" alt="Rendered LaTeX preview" class="preview" />
          </div>
          <div class="meta">
            <div id="meta-size">—</div>
            <div id="meta-type">PNG</div>
            <div id="meta-bg">BG: #FFFFFF</div>
          
<div id="solveOutput" class="solve-panel" role="region" aria-live="polite"></div>
        </div>
      </section>
    </div>

    <section class="panel" style="margin-top:18px" aria-labelledby="history-title">
      <h2 id="history-title">History (local)</h2>
      <div class="body">
        <div class="history" id="history"></div>
      </div>
    </section>

    <footer>
      <div>
        Built with MathJax (TeX→SVG), JSZip, and localStorage. Fully standalone single-file app.
      </div>
    </footer>
  </main>

  <script>
  (function(){
    const $ = sel => document.querySelector(sel);
    const $$ = sel => Array.from(document.querySelectorAll(sel));

    const els = {
      body: document.getElementById('body'),
      latex: $('#latex'),
      renderBtn: $('#renderBtn'),
      liveToggle: $('#liveToggle'),
      preview: $('#preview'),
      status: $('#status'),
      metaSize: $('#meta-size'),
      metaType: $('#meta-type'),
      metaBg: $('#meta-bg'),
      scale: $('#scale'),
      padding: $('#padding'),
      bg: $('#bg'),
      transparent: $('#transparent'),
      downloadPNGBtn: $('#downloadPNGBtn'),
      downloadSVGBtn: $('#downloadSVGBtn'),
      copyPNGBtn: $('#copyPNGBtn'),
      copySVGBtn: $('#copySVGBtn'),
      clearBtn: $('#clearBtn'),
      shareBtn: $('#shareBtn'),
      saveHistoryBtn: $('#saveHistoryBtn'),
      history: $('#history'),
      themeToggle: $('#themeToggle'),
      templates: $('#templates'),
      templateFilterBtn: $('#templateFilterBtn'),
      templateDropdown: $('#templateDropdown'),
      catList: $('#catList'),
      catSummary: $('#catSummary'),
      selectAll: $('#selectAll'),
      selectNone: $('#selectNone'),
      selectIB: $('#selectIB'),
      batchZipBtn: $('#batchZipBtn'),
    };

    const state = {
      svgText: '',
      pngDataURL: '',
      pngBlob: null,
      live: false,
      dark: false,
      cats: new Set()
    };

    // --- Category filtering ---
    const CATS = [
      ['basics','Basics'],
      ['constants','Constants & sets'],
      ['greek','Greek'],
      ['trig','Trig / exp / logs'],
      ['calculus','Calculus'],
      ['algebra','Algebra / relations'],
      ['arrows','Arrows'],
      ['matrices','Matrices / vectors / cases'],
      ['geometry','Geometry'],
      ['probability','Probability / stats'],
      ['complex','Complex'],
      ['series','Series / sequences'],
      ['dots','Dots / spacing']];

    const CATS_KEY = 'latren-template-cats-v1';

    function loadCats(){
      try{
        const arr = JSON.parse(localStorage.getItem(CATS_KEY) || 'null');
        if(Array.isArray(arr) && arr.length){ state.cats = new Set(arr); }
        else { state.cats = new Set(CATS.map(([k])=>k)); }
      }catch{ state.cats = new Set(CATS.map(([k])=>k)); }
    }
    function saveCats(){ localStorage.setItem(CATS_KEY, JSON.stringify([...state.cats])); }
    function applyCategoryFilter(){
      const allBtns = $$('.template');
      allBtns.forEach(btn => {
        const cat = btn.getAttribute('data-cat') || '';
        btn.style.display = state.cats.has(cat) ? '' : 'none';
      });
      const total = allBtns.length;
      const shown = allBtns.filter(b => b.style.display !== 'none').length;
      els.catSummary.textContent = `${shown}/${total} keys visible`;
    }
    function buildCatUI(){
      els.catList.innerHTML = '';
      CATS.forEach(([key,label]) => {
        const id = 'cat-' + key;
        const wrap = document.createElement('label');
        wrap.setAttribute('for', id);
        const cb = document.createElement('input');
        cb.type = 'checkbox'; cb.id = id; cb.checked = state.cats.has(key);
        cb.dataset.key = key;
        cb.addEventListener('change', () => {
          if(cb.checked) state.cats.add(key); else state.cats.delete(key);
          saveCats(); applyCategoryFilter();
        });
        const span = document.createElement('span'); span.textContent = label;
        wrap.appendChild(cb); wrap.appendChild(span);
        els.catList.appendChild(wrap);
      });
    }
    function openDropdown(){
      els.templateDropdown.hidden = false;
      els.templateFilterBtn.setAttribute('aria-expanded', 'true');
      buildCatUI();
      document.addEventListener('click', onDocClick, { once: true });
      document.addEventListener('keydown', onEsc, { once: true });
    }
    function closeDropdown(){
      els.templateDropdown.hidden = true;
      els.templateFilterBtn.setAttribute('aria-expanded', 'false');
    }
    function onDocClick(e){
      if(!els.templateDropdown.contains(e.target) && e.target !== els.templateFilterBtn){
        closeDropdown();
      } else { document.addEventListener('click', onDocClick, { once: true }); }
    }
    function onEsc(e){
      if(e.key === 'Escape') closeDropdown();
      else document.addEventListener('keydown', onEsc, { once: true });
    }

    els.templateFilterBtn.addEventListener('click', ()=>{
      const opened = els.templateDropdown.hidden === false;
      if(opened) closeDropdown(); else openDropdown();
    });
    els.selectAll.addEventListener('click', ()=>{ state.cats = new Set(CATS.map(([k])=>k)); saveCats(); buildCatUI(); applyCategoryFilter(); });
    els.selectNone.addEventListener('click', ()=>{ state.cats = new Set(); saveCats(); buildCatUI(); applyCategoryFilter(); });
    els.selectIB.addEventListener('click', ()=>{ state.cats = new Set(['basics','greek','calculus','algebra','matrices','probability','series']); saveCats(); buildCatUI(); applyCategoryFilter(); });

    // Theme
    els.themeToggle.addEventListener('change', () => {
      state.dark = els.themeToggle.checked;
      document.body.classList.toggle('light', !state.dark);
      document.body.classList.toggle('dark', state.dark);
    });

    // Template insertion: normalize to single backslashes
    $$('.template').forEach(btn => btn.addEventListener('click', () => {
      const raw = btn.getAttribute('data-snippet') || '';
      const single = raw.replace(/\\\\/g, '\\');
      insertAtCursor(els.latex, single);
      if(state.live) render();
    }));

    function insertAtCursor(textarea, text){
      const start = textarea.selectionStart ?? textarea.value.length;
      const end = textarea.selectionEnd ?? textarea.value.length;
      const value = textarea.value;
      textarea.value = value.slice(0,start) + text + value.slice(end);
      textarea.focus();
      textarea.selectionStart = textarea.selectionEnd = start + text.length;
    }

    // Live toggle
    els.liveToggle.addEventListener('click', () => {
      state.live = !state.live;
      els.liveToggle.setAttribute('aria-pressed', String(state.live));
      els.liveToggle.textContent = `Live: ${state.live ? 'On' : 'Off'}`;
      if(state.live) render();
    });

    // Status helpers
    function setStatus(msg, cls){ els.status.textContent = msg; els.status.className = 'status ' + (cls || ''); }
    function clearStatus(){ els.status.textContent = ''; els.status.className = 'status'; }

    // Render: TeX -> SVG -> PNG
    async function render(){
      clearStatus();
      const tex = els.latex.value.trim();
      if(!tex){ setStatus('Enter some LaTeX to render.', 'err'); return; }

      if(window.MathJax?.startup?.promise){ await MathJax.startup.promise; }

      let svgNode;
      try {
        svgNode = await MathJax.tex2svgPromise(tex, {display:true});
      } catch (err) {
        console.error(err);
        setStatus('LaTeX parse error. Tip: use \\[...\\] or environments; wrap text with \\text{...}', 'err');
        return;
      }

      const svg = svgNode.querySelector('svg');
      if(!svg){ setStatus('Failed to create SVG.', 'err'); return; }
      svg.setAttribute('xmlns','http://www.w3.org/2000/svg');
      svg.removeAttribute('style');

      const ser = new XMLSerializer();
      let svgText = ser.serializeToString(svg);
      if(!svgText.startsWith('<?xml')) svgText = `<?xml version="1.0" encoding="UTF-8"?>\n` + svgText;
      state.svgText = svgText;

      try {
        const {dataURL, blob, canvas} = await svgToPng(svgText, readScale(), readBg(), readPadding());
        els.preview.src = dataURL;
        state.pngDataURL = dataURL;
        state.pngBlob = blob;
        els.metaSize.textContent = `${canvas.width} × ${canvas.height}px`;
        els.metaType.textContent = 'PNG';
        els.metaBg.textContent = `BG: ${els.transparent.checked ? 'transparent' : els.bg.value.toUpperCase()}`;
      } catch (err) {
        console.error(err);
        setStatus('Render error: ' + (err.message || err.toString()), 'err');
        return;
      }
      setStatus('Rendered successfully ✓', 'ok');
      saveDraft();
    }

    function readScale(){ return clamp(parseFloat(els.scale.value)||1, 0.1, 8); }
    function readPadding(){ return Math.max(0, parseInt(els.padding.value||0,10)); }
    function readBg(){ return els.transparent.checked ? 'transparent' : els.bg.value; }
    function clamp(v, mn, mx){ return Math.max(mn, Math.min(mx, v)); }

    function svgToPng(svgText, scale, bgColor, padding){
      return new Promise((resolve, reject) => {
        const img = new Image();
        const blob = new Blob([svgText], {type:'image/svg+xml'});
        const url = URL.createObjectURL(blob);
        img.onload = () => {
          const w = Math.ceil(img.width * scale + 2*padding);
          const h = Math.ceil(img.height * scale + 2*padding);
          const canvas = document.createElement('canvas');
          canvas.width = w; canvas.height = h;
          const ctx = canvas.getContext('2d');
          if(bgColor !== 'transparent'){
            ctx.fillStyle = bgColor;
            ctx.fillRect(0,0,w,h);
          }
          ctx.imageSmoothingQuality = 'high';
          ctx.drawImage(img, padding, padding, img.width * scale, img.height * scale);
          canvas.toBlob(b => {
            URL.revokeObjectURL(url);
            if(!b) return reject(new Error('Failed to create PNG blob'));
            resolve({blob: b, dataURL: URL.createObjectURL(b), canvas});
          }, 'image/png');
        };
        img.onerror = e => { URL.revokeObjectURL(url); reject(e); };
        img.src = url;
      });
    }

    // Downloads & clipboard
    function download(name, blob){
      const a = document.createElement('a');
      const url = URL.createObjectURL(blob);
      a.href = url; a.download = name; a.click();
      setTimeout(() => URL.revokeObjectURL(url), 500);
    }

    els.downloadPNGBtn.addEventListener('click', async () => {
      if(!state.pngBlob) await render();
      const name = suggestName('latren', 'png');
      download(name, state.pngBlob);
    });

    els.downloadSVGBtn.addEventListener('click', () => {
      if(!state.svgText){ setStatus('Nothing to download. Render first.', 'err'); return; }
      const blob = new Blob([state.svgText], {type:'image/svg+xml'});
      download(suggestName('latren','svg'), blob);
    });

    els.copyPNGBtn.addEventListener('click', async () => {
      try{
        if(!state.pngBlob) await render();
        await navigator.clipboard.write([ new ClipboardItem({ 'image/png': state.pngBlob }) ]);
        setStatus('PNG copied to clipboard ✓', 'ok');
      }catch(err){ setStatus('Clipboard not available: ' + err, 'err'); }
    });

    els.copySVGBtn.addEventListener('click', async () => {
      try{
        if(!state.svgText) await render();
        const type = 'image/svg+xml';
        const blob = new Blob([state.svgText], {type});
        await navigator.clipboard.write([ new ClipboardItem({ [type]: blob }) ]);
        setStatus('SVG copied to clipboard ✓', 'ok');
      }catch(err){ setStatus('Clipboard not available: ' + err, 'err'); }
    });

    // Share link
    els.shareBtn.addEventListener('click', () => {
      const url = buildShareUrl();
      navigator.clipboard.writeText(url).then(() => setStatus('Sharable link copied ✓', 'ok'));
      history.replaceState(null, '', url);
    });

    function buildShareUrl(){
      const o = new URL(location.href);
      const params = new URLSearchParams();
      params.set('q', b64enc(els.latex.value));
      params.set('s', String(els.scale.value));
      params.set('p', String(els.padding.value));
      params.set('t', els.transparent.checked ? '1' : '0');
      return `${o.origin}${o.pathname}#${params.toString()}`;
    }
    function parseShareUrl(){
      if(!location.hash) return;
      const qs = location.hash.slice(1);
      const params = new URLSearchParams(qs);
      if(params.has('q')){ try{ els.latex.value = b64dec(params.get('q')||''); }catch{} }
      if(params.has('s')) els.scale.value = params.get('s');
      if(params.has('p')) els.padding.value = params.get('p');
      if(params.has('t')) els.transparent.checked = params.get('t')==='1';
    }
    function b64enc(str){ return btoa(unescape(encodeURIComponent(str))); }
    function b64dec(str){ return decodeURIComponent(escape(atob(str))); }
    function suggestName(base, ext){ const t = new Date().toISOString().replace(/[:.]/g,'-'); return `${base}-${t}.${ext}`; }

    // History (localStorage)
    const HISTORY_KEY = 'latren-history-v1';
    function loadHistory(){ try{ const arr = JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]'); return Array.isArray(arr) ? arr : []; }catch{ return []; } }
    function saveHistoryCard(item){
      const card = document.createElement('div');
      card.className = 'card';
      const img = document.createElement('img'); img.src = item.pngURL; img.alt = 'Formula preview';
      const info = document.createElement('div'); info.className='info';
      const small = document.createElement('small'); small.textContent = new Date(item.time).toLocaleString(); info.appendChild(small);
      const actions = document.createElement('div'); actions.className='actions';
      const btnUse = document.createElement('button'); btnUse.className='btn secondary'; btnUse.textContent='Load';
      const btnDL = document.createElement('button'); btnDL.className='btn'; btnDL.textContent='PNG';
      btnUse.onclick = () => { els.latex.value = item.latex; if(state.live) render(); window.scrollTo({top:0, behavior:'smooth'}); };
      btnDL.onclick = () => fetch(item.pngURL).then(r=>r.blob()).then(b=>download(suggestName('latren','png'), b));
      actions.appendChild(btnUse); actions.appendChild(btnDL);
      card.appendChild(img); card.appendChild(info); card.appendChild(actions);
      els.history.prepend(card);
    }
    function refreshHistory(){ els.history.innerHTML = ''; loadHistory().forEach(saveHistoryCard); }
    function addToHistory(){
      if(!state.pngDataURL) { setStatus('Render first to save history.', 'err'); return; }
      const items = loadHistory();
      const entry = { latex: els.latex.value, pngURL: state.pngDataURL, time: Date.now() };
      items.unshift(entry); while(items.length > 24) items.pop();
      localStorage.setItem(HISTORY_KEY, JSON.stringify(items));
      saveHistoryCard(entry);
      setStatus('Saved to history ✓', 'ok');
    }
    els.saveHistoryBtn.addEventListener('click', addToHistory);

    // Draft
    const DRAFT_KEY = 'latren-draft-v1';
    function saveDraft(){ localStorage.setItem(DRAFT_KEY, JSON.stringify({ latex: els.latex.value, scale: els.scale.value, padding: els.padding.value, bg: els.bg.value, transparent: els.transparent.checked })); }
    function loadDraft(){ try{ const d = JSON.parse(localStorage.getItem(DRAFT_KEY)||'null'); if(d){ els.latex.value = d.latex||els.latex.value; els.scale.value = d.scale||els.scale.value; els.padding.value = d.padding||els.padding.value; els.bg.value = d.bg||els.bg.value; els.transparent.checked = !!d.transparent; } }catch{} }

    // Clear
    els.clearBtn.addEventListener('click', () => {
      els.latex.value=''; state.svgText=''; state.pngDataURL=''; state.pngBlob=null; els.preview.removeAttribute('src'); els.metaSize.textContent='—'; clearStatus(); saveDraft();
    });

    ['input','change'].forEach(ev => {
      [els.latex, els.scale, els.padding, els.bg, els.transparent].forEach(el => {
        el.addEventListener(ev, () => { saveDraft(); if(state.live) render(); });
      });
    });

    els.renderBtn.addEventListener('click', render);

    document.addEventListener('keydown', (e) => {
      if((e.ctrlKey||e.metaKey) && e.key==='Enter'){ e.preventDefault(); render(); }
      if((e.ctrlKey||e.metaKey) && (e.key==='s' || e.key==='S')){ e.preventDefault(); els.downloadPNGBtn.click(); }
      if((e.ctrlKey||e.metaKey) && (e.key==='k' || e.key==='K')){ e.preventDefault(); els.copyPNGBtn.click(); }
    });

    // --- Batch → ZIP ---
    els.batchZipBtn.addEventListener('click', batchToZip);

    function splitIntoJobs(text){
      // Split by two or more newlines; trim each block; filter empty.
      return text.split(/\r?\n\r?\n+/).map(s => s.trim()).filter(Boolean);
    }

    
    // New splitter: split by single line breaks, but keep multi-line TeX blocks intact.
    function splitIntoJobsLines(text){
      const lines = (text || '').replace(/\r\n/g, '\n').split('\n');
      const jobs = [];
      let i = 0;

      const countDollars = (s)=> (s.match(/\$\$/g) || []).length;

      while (i < lines.length) {
        let line = (lines[i] || '').trim();
        i++;
        if (!line) continue;

        // \[ ... \]
        if (line.includes('\\[') && !line.includes('\\]')) {
          let block = line;
          while (i < lines.length) {
            block += '\n' + lines[i];
            if ((lines[i] || '').includes('\\]')) { i++; break; }
            i++;
          }
          jobs.push(block.trim());
          continue;
        }

        // $$ ... $$ (balance odd $$ counts)
        if (countDollars(line) % 2 === 1) {
          let block = line;
          while (i < lines.length) {
            block += '\n' + lines[i];
            if (countDollars(lines[i] || '') % 2 === 1) { i++; break; }
            i++;
          }
          jobs.push(block.trim());
          continue;
        }

        // \begin{env} ... \end{env}
        const m = line.match(/\\begin\{([^}]+)\}/);
        if (m) {
          const env = m[1];
          if (!line.includes(`\\end{${env}}`)) {
            let block = line;
            while (i < lines.length) {
              block += '\n' + lines[i];
              if ((lines[i] || '').includes(`\\end{${env}}`)) { i++; break; }
              i++;
            }
            jobs.push(block.trim());
            continue;
          }
        }

        jobs.push(line);
      }
      return jobs;
    }

async function batchToZip(){
      clearStatus();
      const raw = els.latex.value || '';
      const blocks = splitIntoJobsLines(raw);
      if(blocks.length === 0){ setStatus('Nothing to batch: separate formulas with a blank line.', 'err'); return; }

      if(window.MathJax?.startup?.promise){ await MathJax.startup.promise; }

      const zip = new JSZip();
      const fPNG = zip.folder('png');
      const fSVG = zip.folder('svg');
      const meta = [];
      const errors = [];

      const digits = String(blocks.length).length;
      const pad = n => String(n).padStart(digits, '0');
      const scale = readScale();
      const padding = readPadding();
      const bg = readBg();
      setStatus(`Batch: ${blocks.length} item(s)…`, 'ok');

      for(let i=0;i<blocks.length;i++){
        const idx = i+1, label = pad(idx);
        const tex = blocks[i];
        setStatus(`Rendering ${idx}/${blocks.length}…`, 'ok');

        try{
          const svgNode = await MathJax.tex2svgPromise(tex, {display:true});
          const svg = svgNode.querySelector('svg');
          if(!svg) throw new Error('No SVG produced');

          svg.setAttribute('xmlns','http://www.w3.org/2000/svg');
          svg.removeAttribute('style');
          const ser = new XMLSerializer();
          let svgText = ser.serializeToString(svg);
          if(!svgText.startsWith('<?xml')) svgText = `<?xml version="1.0" encoding="UTF-8"?>\n` + svgText;

          const { blob: pngBlob } = await svgToPng(svgText, scale, bg, padding);

          fSVG.file(`${label}.svg`, svgText);
          const pngArrayBuf = await blobToArrayBuffer(pngBlob);
          fPNG.file(`${label}.png`, pngArrayBuf);

          meta.push(`${label}\tchars=${tex.length}\tscale=${scale}\tpadding=${padding}\tbg=${bg}`);
        }catch(err){
          const msg = (err && (err.message || String(err))) || 'Unknown error';
          errors.push(`Item ${label}: ${msg}\n---\n${tex}\n---\n`);
        }
      }

      zip.file('manifest.txt', meta.join('\n'));
      if(errors.length){ zip.file('errors.txt', errors.join('\n\n')); }

      setStatus('Packaging ZIP…', 'ok');
      const blob = await zip.generateAsync({type:'blob', compression: 'DEFLATE'});
      download(suggestName('latren-batch','zip'), blob);
      setStatus(`Done ✓  PNG: /png/*.png · SVG: /svg/*.svg${errors.length ? ` · ${errors.length} error(s) logged` : ''}`, 'ok');
    }

    function blobToArrayBuffer(blob){
      return new Promise((resolve,reject)=>{
        const fr = new FileReader();
        fr.onload = () => resolve(fr.result);
        fr.onerror = reject;
        fr.readAsArrayBuffer(blob);
      });
    }

// --- Solve: LaTeX → MathML → AST → steps/answers + computable strings ---
// Wire up elements
els.solveBtn = document.getElementById('solveBtn');
const solveOutput = document.getElementById('solveOutput');

if(els.solveBtn){
  els.solveBtn.addEventListener('click', () => { solveOutput && solveCurrent(); });
}

function getActiveLatex(){
  const ta = els.latex;
  const sel = (ta.selectionStart ?? 0) !== (ta.selectionEnd ?? 0)
    ? ta.value.slice(ta.selectionStart, ta.selectionEnd).trim()
    : '';
  if(sel) return sel;
  // Fallback to last non-empty block, consistent with Batch splitter
  const blocks = splitIntoJobsLines(ta.value || '');
  if(blocks.length) return blocks[blocks.length - 1];
  return (ta.value || '').trim();
}

function stripDelims(tex){
  // Remove common block delimiters \[...\], $$...$$, or wrapping \begin{...}...\end{...}
  let t = tex.trim();
  t = t.replace(/^\s*\\\[(.*)\\\]\s*$/s, '$1');
  t = t.replace(/^\s*\$\$(.*)\$\$\s*$/s, '$1');
  // Simple begin/end stripping (single pair)
  t = t.replace(/^\s*\\begin\{[^}]+\}\s*([\s\S]*?)\s*\\end\{[^}]+\}\s*$/s, '$1');
  return t.trim();
}

async function solveCurrent(){
  if(!solveOutput) return;
  solveOutput.innerHTML = ''; // clear
  const raw = getActiveLatex();
  if(!raw){ solveOutput.innerHTML = errCard('Empty input.'); return; }

  const tex = stripDelims(raw);
  try{
    if(window.MathJax?.startup?.promise){ await MathJax.startup.promise; }
  }catch{}

  // Obtain MathML for parsing
  let mml;
  try{
    mml = await MathJax.tex2mmlPromise(tex);
  }catch(err){
    solveOutput.innerHTML = errCard('LaTeX parse error — check delimiters or unbalanced braces.');
    return;
  }

  // Parse MathML → AST
  let ast;
  try{
    ast = mmlToAst(mml);
  }catch(err){
    console.error(err);
    solveOutput.innerHTML = errCard('Unsupported or unrecognized MathML structure.');
    return;
  }

  // Must be an equation a = b
  if(ast.type !== 'eq'){
    solveOutput.innerHTML = errCard('No equality sign found. Provide an equation like \\(2(x-3)=7\\).');
    MathJax.typesetPromise([solveOutput]).catch(()=>{});
    return;
  }

  const vars = [...detectVars(ast)];
  let targetVar = vars[0] || 'x';

  // Try to solve as polynomial in a single variable
  if(vars.length === 0){
    solveOutput.innerHTML = errCard('No variable detected to solve for.');
    return;
  }
  if(vars.length > 1){
    // Attempt to prefer x if present
    if(vars.includes('x')) targetVar = 'x';
  }

  // Build polynomial on one side: (LHS - RHS) == 0
  const diffAst = { type:'op', op:'-', left: ast.left, right: ast.right };

  const poly = toPolynomial(diffAst, targetVar);
  if(!poly){
    // Still show computable forms for external CAS, even if our local solver can't handle
    const comp = buildComputableStrings(ast, targetVar, tex);
    solveOutput.innerHTML = [
      headerCard('Solution'),
      `<div class="solve-meta">Detected variable(s): <code class="inline">${vars.join(', ')}</code>. Local solver supports linear/quadratic polynomials; this one looks more complex.</div>`,
      compBlock(comp),
    ].join('');
    MathJax.typesetPromise([solveOutput]).catch(()=>{});
    return;
  }

  // Simplify coefficients (merge tiny)
  const eps = 1e-12;
  const coeffs = trimCoeffs(poly.coeffs.map(c => Math.abs(c) < eps ? 0 : c));
  const deg = coeffs.length - 1;

  let steps = [];
  // Step 1: Original equation
  steps.push(stepItem('Start with the equation','Given by the user', `\\(${escapeLatex(tex)}\\)`, stringifyEq(ast)));

  // Step 2: Move all terms to the left
  const movedLatex = polyLatex(coeffs, targetVar) + '=0';
  steps.push(stepItem('Move all terms to one side','Subtract RHS from both sides', `\\(${movedLatex}\\)`, polyText(coeffs, targetVar) + ' = 0'));

  let answers = [];
  if(deg === 1){
    const a = coeffs[1], b = coeffs[0];
    if(Math.abs(a) < eps){
      solveOutput.innerHTML = errCard('Degenerate linear form (a=0).');
      return;
    }
    const x = -b / a;
    steps.push(stepItem('Isolate the variable', 'Divide both sides by the coefficient of the variable', `\\(${targetVar} = ${numLatex(x)}\\)`, `${targetVar} = ${x}`));
    answers = [x];
  } else if (deg === 2){
    const a = coeffs[2], b = coeffs[1], c = coeffs[0];
    const disc = b*b - 4*a*c;
    const discLatex = `${numLatex(b)}^{2} - 4\\cdot ${numLatex(a)}\\cdot ${numLatex(c)}`;
    steps.push(stepItem('Apply the quadratic formula','For \\(ax^2+bx+c=0\\), roots are \\(\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}\\)', 
      `\\(x = \\frac{-(${numLatex(b)}) \\pm \\sqrt{${discLatex}}}{2\\cdot ${numLatex(a)}}\\)`,
      'quadratic formula'));
    if(disc < 0){
      // Complex roots
      const real = -b/(2*a);
      const imag = Math.sqrt(-disc)/(2*a);
      answers = [real + imag*1, real - imag*1]  // placeholder, we'll render as strings
      // We'll convert below to strings
    }else{
      const x1 = (-b + Math.sqrt(disc)) / (2*a);
      const x2 = (-b - Math.sqrt(disc)) / (2*a);
      answers = [x1, x2];
    }
  } else if (deg === 0){
    // c = 0: either identity or contradiction
    const c0 = coeffs[0] || 0;
    if(Math.abs(c0) < eps){
      solveOutput.innerHTML = infoCard('This equation is an identity (true for all values of the variable).');
    }else{
      solveOutput.innerHTML = errCard('No solution: the equation reduces to a nonzero constant = 0.');
    }
    // Still show computable forms
    const comp = buildComputableStrings(ast, targetVar, tex);
    solveOutput.innerHTML += compBlock(comp);
    MathJax.typesetPromise([solveOutput]).catch(()=>{});
    return;
  } else {
    // Degree > 2
    const comp = buildComputableStrings(ast, targetVar, tex);
    solveOutput.innerHTML = [
      headerCard('Solution'),
      `<div class="solve-meta">Detected variable(s): <code class="inline">${vars.join(', ')}</code>. Local solver handles up to quadratics; detected degree ${deg}.</div>`,
      compBlock(comp),
    ].join('');
    MathJax.typesetPromise([solveOutput]).catch(()=>{});
    return;
  }

  // Verification of solutions
  const ver = verifySolutions(ast, targetVar, answers);

  // Assemble UI
  const comp = buildComputableStrings(ast, targetVar, tex);
  solveOutput.innerHTML = [
    headerCard('Solution'),
    `<div class="solve-meta">Solve for <code class="inline">${targetVar}</code>. Detected variable(s): <code class="inline">${vars.join(', ')}</code>.</div>`,
    stepsList(steps),
    answersBlock(answers, targetVar),
    verifyBlock(ver),
    compBlock(comp),
  ].join('');

  // Typeset LaTeX within the panel
  try{ await MathJax.typesetPromise([solveOutput]); }catch{}
}

function headerCard(title){ return `<h3>${title}</h3>`; }
function infoCard(msg){ return `<div class="solve-panel"><h3>Solution</h3><div class="solve-meta">${msg}</div></div>`; }
function errCard(msg){ return `<div class="solve-panel"><h3>Solution</h3><div class="solve-err">${msg}</div></div>`; }

function stepItem(what, why, latexStr, plain){
  return { what, why, latexStr, plain };
}
function stepsList(steps){
  return `<ol class="solve-steps">` + steps.map(s => (
    `<li>
       <div class="solve-what">${escapeHtml(s.what)}</div>
       <div class="solve-why">${escapeHtml(s.why)}</div>
       <div class="solve-math">${s.latexStr}</div>
       <div class="solve-plain" style="font-family:'JetBrains Mono', monospace; font-size:12px; color:var(--muted)">${escapeHtml(s.plain)}</div>
     </li>`
  )).join('') + `</ol>`;
}

function answersBlock(arr, varName){
  if(!arr || !arr.length) return '';
  const items = arr.map((v,i) => {
    if (typeof v === 'number'){
      return `<div>${varName}${arr.length>1?`_${i+1}`:''} = ${numPretty(v)} <span class="badge-ok">≈</span></div>`;
    } else if (typeof v === 'string'){
      return `<div>${varName}${arr.length>1?`_${i+1}`:''} = ${escapeHtml(v)}</div>`;
    } else {
      // complex number object fallback (not used)
      return `<div>${varName}${arr.length>1?`_${i+1}`:''} = ${escapeHtml(String(v))}</div>`;
    }
  }).join('');
  return `<div class="answers"><strong>Numeric answer(s):</strong>${items}</div>`;
}

function verifyBlock(ver){
  if(!ver) return '';
  const rows = ver.map(v => {
    const badge = Math.abs(v.residual) <= 1e-7 ? '✓' : '✗';
    return `<div>${escapeHtml(v.label)}: |LHS−RHS| ≈ ${numPretty(Math.abs(v.residual))} ${badge}</div>`;
  }).join('');
  return `<div class="verify"><strong>Verification:</strong> ${rows}</div>`;
}

function compBlock(comp){
  const rows = [
    ['SymPy', comp.sympy],
    ['MATLAB', comp.matlab],
    ['Mathematica', comp.mathematica],
    ['MathJS', comp.mathjs],
  ].map(([label,code],i)=>{
    const id = 'code-'+label.toLowerCase()+'-'+Math.random().toString(36).slice(2);
    return `<div class="code-row">
      <span style="width:110px; color:var(--muted); font-size:12px">${label}</span>
      <code id="${id}">${escapeHtml(code)}</code>
      <button class="btn secondary mini" type="button" onclick="(function(){ const t=document.getElementById('${id}').innerText; navigator.clipboard.writeText(t); })()">Copy</button>
    </div>`;
  }).join('');
  return `<details class="code-list"><summary>Computable forms</summary>${rows}</details>`;
}

function numLatex(n){
  // Render as numeric string in LaTeX (limited)
  if(Number.isInteger(n)) return String(n);
  return n.toPrecision(10);
}
function numPretty(n){
  const abs = Math.abs(n);
  if(abs>=1e6 || (abs>0 && abs<1e-4)) return n.toExponential(6);
  return (+n.toFixed(10)).toString();
}

function escapeHtml(s){ return (s||'').replace(/[&<>]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }
function escapeLatex(s){ return (s||'').replace(/\\/g,'\\\\'); }

// --- MathML → AST ---
function mmlToAst(mmlString){
  const doc = new DOMParser().parseFromString(mmlString, 'application/xml');
  const math = doc.documentElement.nodeName.toLowerCase()==='math' ? doc.documentElement : doc.querySelector('math');
  if(!math) throw new Error('No <math> root');
  const node = parseNode(math);
  // If top isn't eq, try to locate '=' at top level of an mrow
  if(node.type==='mrow' && node.tokens){
    const eqIdx = node.tokens.findIndex(t => typeof t==='string' && t==='=');
    if(eqIdx>=0){
      const leftTok = node.tokens.slice(0,eqIdx);
      const rightTok = node.tokens.slice(eqIdx+1);
      return { type:'eq', left: buildFromTokens(leftTok), right: buildFromTokens(rightTok) };
    }
  }
  if(node.type==='op' && node.op==='='){
    return { type:'eq', left: node.left, right: node.right };
  }
  return node;
}

function parseNode(el){
  const tag = el.nodeName.toLowerCase();
  if(tag==='math' || tag==='mrow'){
    // flatten children to tokens
    const tokens = [];
    let prevWasAst = false;
    el.childNodes.forEach(ch => {
      if(ch.nodeType!==1) return;
      const t = ch.nodeName.toLowerCase();
      if(t==='mo'){
        const opTxt = normalizeOp(ch.textContent || '');
        if(opTxt){ tokens.push(opTxt); prevWasAst=false; }
      } else if (t==='mspace') {
        // ignore
      } else {
        const ast = parseNode(ch);
        tokens.push(ast);
        // implicit multiplication between adjacent ASTs
        if(prevWasAst){ tokens.splice(tokens.length-1, 0, '*'); }
        prevWasAst = true;
        return;
      }
    });
    return { type:'mrow', tokens };
  }
  if(tag==='mn'){ return { type:'num', value: parseFloat(el.textContent) }; }
  if(tag==='mi'){
    const name = (el.textContent || '').trim();
    return { type:'var', name };
  }
  if(tag==='mo'){
    // single operator node appears rarely alone here
    return { type:'op', op: normalizeOp(el.textContent||''), left:null, right:null };
  }
  if(tag==='mfrac'){
    const [a,b] = childAsts(el);
    return { type:'op', op:'/', left:a, right:b };
  }
  if(tag==='msup'){
    const [a,b] = childAsts(el);
    return { type:'op', op:'^', left:a, right:b };
  }
  if(tag==='msub'){
    const [a,_b] = childAsts(el);
    return a; // ignore subscripts in solving
  }
  if(tag==='msubsup'){
    const [a,_b,c] = childAsts(el);
    return { type:'op', op:'^', left:a, right:c };
  }
  if(tag==='msqrt'){
    const [a] = childAsts(el);
    return { type:'func', name:'sqrt', args:[a] };
  }
  if(tag==='mfenced'){
    // Treat as mrow with children (parentheses are implicit in structure)
    const mrow = document.createElement('mrow');
    el.childNodes.forEach(n=>mrow.appendChild(n.cloneNode(true)));
    return parseNode(mrow);
  }
  // Default: try to parse children as a row
  if(el.childNodes && el.childNodes.length){
    const mrow = document.createElement('mrow');
    el.childNodes.forEach(n=>{ if(n.nodeType===1) mrow.appendChild(n.cloneNode(true)); });
    return parseNode(mrow);
  }
  throw new Error('Unhandled MathML tag: ' + tag);
}

function childAsts(el){
  const arr = [];
  el.childNodes.forEach(ch => { if(ch.nodeType===1) arr.push(parseNode(ch)); });
  return arr;
}

function normalizeOp(s){
  s = s.trim();
  if(s==='−' || s==='–' || s==='—') s='-';
  if(s==='·' || s==='⋅' || s==='⁢') s='*';
  if(s==='×') s='*';
  if(s==='÷') s='/';
  return s;
}

// Build AST from tokens via shunting-yard
function buildFromTokens(tokens){
  if(tokens.length===1 && typeof tokens[0] !== 'string') return tokens[0];
  const output = [];
  const ops = [];
  const prec = {'=':0,'+':1,'-':1,'*':2,'/':2,'^':3};
  const rightAssoc = {'^':true};
  function apply(){
    const op = ops.pop();
    const b = output.pop();
    const a = output.pop();
    output.push({ type:'op', op, left:a, right:b });
  }
  for(const t of tokens){
    if(typeof t === 'string'){
      if(!(t in prec)) continue; // skip unsupported
      while(ops.length){
        const top = ops[ops.length-1];
        if( (rightAssoc[t] && prec[t] < prec[top]) || (!rightAssoc[t] && prec[t] <= prec[top]) ){
          apply(); continue;
        }
        break;
      }
      ops.push(t);
    } else {
      output.push(t);
    }
  }
  while(ops.length) apply();
  if(output.length!==1) throw new Error('Parse error building AST');
  return output[0];
}

function detectVars(ast){
  const set = new Set();
  (function walk(n){
    if(!n) return;
    if(n.type==='var'){ set.add(n.name); }
    else if(n.type==='op'){ walk(n.left); walk(n.right); }
    else if(n.type==='eq'){ walk(n.left); walk(n.right); }
    else if(n.type==='func'){ (n.args||[]).forEach(walk); }
    else if(n.type==='mrow' && n.tokens){ n.tokens.forEach(t=>{ if(typeof t!=='string') walk(t); }); }
  })(ast);
  // Filter out function names like 'sin','cos' which MathJax may output as <mi>sin</mi>
  for(const name of [...set]){
    if(/^(sin|cos|tan|log|ln|exp|sqrt)$/i.test(name)) set.delete(name);
  }
  return set;
}

// --- AST → Polynomial coefficients ---
function toPolynomial(node, varName){
  try{
    const coeffs = poly(node);
    return { coeffs };
  }catch{
    return null;
  }

  function poly(n){
    switch(n.type){
      case 'num': {
        const arr = [n.value||0]; return arr;
      }
      case 'var': {
        if(n.name !== varName) throw new Error('other var');
        return [0,1];
      }
      case 'op': {
        if(n.op === '+'){
          const A = poly(n.left), B = poly(n.right);
          return addPoly(A,B);
        }
        if(n.op === '-'){
          const A = poly(n.left), B = poly(n.right);
          return addPoly(A, scalePoly(B, -1));
        }
        if(n.op === '*'){
          const A = poly(n.left), B = poly(n.right);
          return mulPoly(A,B);
        }
        if(n.op === '/'){
          const A = poly(n.left);
          const B = poly(n.right);
          if(B.length !== 1) throw new Error('division by non-constant');
          const k = B[0];
          if(k === 0) throw new Error('division by zero');
          return scalePoly(A, 1/k);
        }
        if(n.op === '^'){
          // exponent must be nonnegative integer constant
          if(n.right.type === 'num' && Number.isFinite(n.right.value) && Math.abs(n.right.value - Math.round(n.right.value))<1e-12 && n.right.value>=0){
            const base = poly(n.left);
            let res = [1];
            for(let i=0;i<Math.round(n.right.value);i++) res = mulPoly(res, base);
            return res;
          }
          throw new Error('non-integer power');
        }
        if(n.op === '='){
          // Should not appear here; handled earlier
          throw new Error('unexpected eq');
        }
        throw new Error('op ' + n.op + ' unsupported');
      }
      case 'func': {
        // sqrt, sin, cos, etc. not polynomial
        throw new Error('func unsupported');
      }
      case 'mrow': {
        // build into AST then recurse
        return poly(buildFromTokens(n.tokens||[]));
      }
      case 'eq': {
        // LHS - RHS
        return poly({ type:'op', op:'-', left:n.left, right:n.right });
      }
    }
    throw new Error('unknown node');
  }

  function addPoly(A,B){
    const n = Math.max(A.length, B.length);
    const C = new Array(n).fill(0);
    for(let i=0;i<n;i++){ C[i] = (A[i]||0) + (B[i]||0); }
    return C;
  }
  function scalePoly(A,k){ return A.map(x=>x*k); }
  function mulPoly(A,B){
    const C = new Array(A.length + B.length - 1).fill(0);
    for(let i=0;i<A.length;i++){
      for(let j=0;j<B.length;j++) C[i+j] += (A[i]||0)*(B[j]||0);
    }
    return C;
  }
}

function trimCoeffs(A){
  let i = A.length-1;
  while(i>0 && Math.abs(A[i])<1e-12) i--;
  return A.slice(0,i+1);
}

function polyLatex(A, varName){
  // A[0] + A[1] x + A[2] x^2 + ...
  const parts = [];
  for(let i=A.length-1;i>=0;i--){
    const c = A[i];
    if(!c) continue;
    const sign = c<0 ? ' - ' : (parts.length? ' + ' : '');
    const abs = Math.abs(c);
    let term = '';
    if(i===0){ term = `${numLatex(abs)}`; }
    else if(i===1){
      if(abs===1){ term = `${varName}`; } else term = `${numLatex(abs)}${varName}`;
    } else {
      if(abs===1){ term = `${varName}^{${i}}`; } else term = `${numLatex(abs)}${varName}^{${i}}`;
    }
    parts.push((c<0 ? sign : sign)+term);
  }
  if(parts.length===0) return '0';
  return parts.join('').replace(/^\s*\+\s*/,'').trim() || '0';
}
function polyText(A, varName){
  return polyLatex(A,varName).replace(/\^{/g,'^').replace(/\}/g,'');
}

// --- Stringify for "plain" preview
function stringifyEq(eq){
  return astToInfix(eq.left) + ' = ' + astToInfix(eq.right);
}
function astToInfix(n){
  switch(n.type){
    case 'num': return String(n.value);
    case 'var': return n.name;
    case 'op': {
      const L = astToInfix(n.left), R = astToInfix(n.right);
      if(n.op==='^') return `(${L})^(${R})`;
      return `(${L} ${n.op} ${R})`;
    }
    case 'func': {
      return n.name + '(' + (n.args||[]).map(astToInfix).join(',') + ')';
    }
    case 'eq': return '(' + astToInfix(n.left) + ') = (' + astToInfix(n.right) + ')';
    case 'mrow': return astToInfix(buildFromTokens(n.tokens||[]));
  }
  return '?';
}

// --- Computable strings ---
function buildComputableStrings(eqAst, varName, originalTex){
  // Convert both sides to target notations
  const leftPy = astToSymPy(eqAst.left);
  const rightPy = astToSymPy(eqAst.right);
  const leftStd = astToStd(eqAst.left); // for MATLAB/Mathematica/MathJS
  const rightStd = astToStd(eqAst.right);
  return {
    sympy: `solve(Eq(${leftPy}, ${rightPy}), ${varName})`,
    matlab: `solve(${leftStd}==${rightStd}, ${varName})`,
    mathematica: `Solve[${leftStd}==${rightStd}, ${varName}]`,
    mathjs: `math.solve('${leftStd} = ${rightStd}', '${varName}')` // requires algebra plugin in MathJS
  };
}

function astToSymPy(n){
  switch(n.type){
    case 'num': return String(n.value);
    case 'var': return n.name;
    case 'op': {
      const a = astToSymPy(n.left), b = astToSymPy(n.right);
      if(n.op==='^') return `(${a})**(${b})`;
      return `(${a})${n.op}(${b})`;
    }
    case 'func': {
      if(n.name==='sqrt' && n.args?.length===1) return `sqrt(${astToSymPy(n.args[0])})`;
      // generic
      return `${n.name}(${(n.args||[]).map(astToSymPy).join(',')})`;
    }
    case 'mrow': return astToSymPy(buildFromTokens(n.tokens||[]));
    case 'eq': return `Eq(${astToSymPy(n.left)}, ${astToSymPy(n.right)})`;
  }
  return '?';
}
function astToStd(n){
  // For MATLAB/Mathematica/MathJS: use ^ for power, * for mult
  switch(n.type){
    case 'num': return String(n.value);
    case 'var': return n.name;
    case 'op': {
      const a = astToStd(n.left), b = astToStd(n.right);
      return `(${a})${n.op==='^' ? '^' : n.op}(${b})`;
    }
    case 'func': {
      if(n.name==='sqrt' && n.args?.length===1) return `sqrt(${astToStd(n.args[0])})`;
      return `${n.name}(${(n.args||[]).map(astToStd).join(',')})`;
    }
    case 'mrow': return astToStd(buildFromTokens(n.tokens||[]));
    case 'eq': return `(${astToStd(n.left)})==(${astToStd(n.right)})`;
  }
  return '?';
}

// --- Verification ---
function verifySolutions(eqAst, varName, answers){
  const out = [];
  for(let i=0;i<answers.length;i++){
    const v = answers[i];
    if(typeof v !== 'number'){ out.push({label:`${varName}${answers.length>1?`_${i+1}`:''}`, residual: NaN}); continue; }
    const L = evalAst(eqAst.left, {[varName]: v});
    const R = evalAst(eqAst.right, {[varName]: v});
    out.push({label:`${varName}${answers.length>1?`_${i+1}`:''}`, residual: (L - R)});
  }
  return out;
}

function evalAst(n, env){
  switch(n.type){
    case 'num': return n.value;
    case 'var': return +(env[n.name]);
    case 'op': {
      const a = evalAst(n.left, env), b = evalAst(n.right, env);
      switch(n.op){
        case '+': return a + b;
        case '-': return a - b;
        case '*': return a * b;
        case '/': return a / b;
        case '^': return Math.pow(a,b);
        case '=': return a - b;
      }
      throw new Error('op ' + n.op);
    }
    case 'func': {
      if(n.name==='sqrt'){ return Math.sqrt(evalAst(n.args[0], env)); }
      throw new Error('func ' + n.name);
    }
    case 'mrow': return evalAst(buildFromTokens(n.tokens||[]), env);
  }
  throw new Error('bad node');
}

    // Init
    loadCats(); applyCategoryFilter(); loadDraft(); parseShareUrl(); refreshHistory();
    // Initial render (safe content uses \[...\], not flalign*)
    setTimeout(render, 60);
  })();
  </script>
</body>
</html>